# -*- coding: utf-8 -*-
"""mlp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xIUPUEGngLn1Lk6bne0IAB327jW0OrS6

#Classificação de Números inteiros com algoritmo MLP
> Por: <br/>
> Gustavo Almeida de Jesus<br/>
> Gustavo Jun Nagatomo<br/>
> Lizandro Raposo Paiva<br/>
> Rafael Afonso Stettiner<br/>
> Vitor Marim <br/>

OBS: Os conjuntos de teste devem estar no caminho "/content/sample_data/"

Implementação de Formulas
"""

from abc import ABC, abstractmethod

class Funcao(ABC):
  @abstractmethod
  def calcular(valor: float) -> float:
    pass

  @abstractmethod
  def calcularUsandoDerivada(valor : float) -> float:
    pass

from math import exp

class Sigmoide(Funcao):
  def calcular(self, valor: float) -> float:
    return 1 / (1 + (exp(-valor)))

  def calcularUsandoDerivada(self, valor : float) -> float:
    return (exp(-valor)) / ((1 + (exp(-valor))) ** 2)

class TangenteHiperbolica(Funcao):
  def calcular(self, valor: float) -> float:
    return (exp(valor) - exp(-valor)) / (exp(valor) + exp(-valor))

  def calcularUsandoDerivada(self, valor : float) -> float:
    return 4 / ((exp(valor) + exp(-valor)) ** 2)


class SoftSign(Funcao):
  def calcular(self, valor: float) -> float:
    return valor / (1 + abs(valor))

  def calcularUsandoDerivada(self, valor : float) -> float:
    return 1 / ((1 + abs(valor)) ** 2)

"""Classe do perceptron"""

from random import *

class Perceptron:
  FuncaoDeAtivacao : Funcao
  ListaDePesos : list[float]
  ListaDeltaDosPesos : list[float]
  ListaDeEntradas : list[float]
  Codigo : str
  Entrada : float

  def __init__(self, codigo_camada, numero_neuronio, tamanho):
    self.FuncaoDeAtivacao = SoftSign()

    self.ListaDePesos = []
    for i in range(tamanho):
      self.ListaDePesos.append(uniform(-3,3))

    self.ListaDeltaDosPesos = []
    self.ListaDeEntradas = []
    self.Codigo = str(codigo_camada) + " - " + str(numero_neuronio)
    self.Entrada = 0

  def adicionaEntradas(self, valoresDeEntrada : list[float]):
    self.ListaDeEntradas.clear()
    self.ListaDeEntradas = valoresDeEntrada

  def combinacaoLinear(self, valoresDeEntrada : list[float], valoresDePesos : list[float]) -> float:
    if (len(valoresDeEntrada) != len(valoresDePesos)):
      raise Exception('A quantidade de valores de entrada é diferente da quantidade de pesos. ')
    if (len(valoresDeEntrada) == 0):
      raise Exception('A quantidade de valores de entrada veio zerada. ')
    if (len(valoresDePesos) == 0):
      raise Exception('A quantidade de pesos veio zerada. ')

    resultado : float = 0
    for i in range(len(valoresDeEntrada)):
      resultado += valoresDeEntrada[i] * valoresDePesos[i]

    return resultado

  def calcularSaida(self) -> float:
    self.Entrada = self.combinacaoLinear(self.ListaDeEntradas, self.ListaDePesos)
    return self.FuncaoDeAtivacao.calcular(self.Entrada)

  def backPropagation(self, erro : float, alfa : float) -> float:
    self.ListaDeltaDosPesos.clear()

    fatorErro = erro * self.FuncaoDeAtivacao.calcularUsandoDerivada(self.Entrada)

    for i in range(len(self.ListaDePesos)):
      self.ListaDeltaDosPesos.append(alfa * fatorErro * self.ListaDeEntradas[i])

    return fatorErro

  def atualizaPesos(self):
    for i in range(len(self.ListaDePesos)):
      self.ListaDePesos[i] += self.ListaDeltaDosPesos[i]

  def mostrarPesos(self):
    print(self.Codigo + " -> ")
    print(self.ListaDePesos)
    print(" ")

"""Classe da Camada"""

import pdb

class Camada:
  ListaDeNeuronios : list[Perceptron]

  def __init__(self, codigo_camada, numero_de_neuronios):
    self.ListaDeNeuronios = []

    for i in range(numero_de_neuronios):
      neuronio = Perceptron(codigo_camada, i, numero_de_neuronios)
      self.ListaDeNeuronios.append(neuronio)

  def calcular(self, valoresDeEntrada : list[float]) -> list[float]:
    if (len(self.ListaDeNeuronios) == 0):
      return valoresDeEntrada

    resultado : list[float] = []
    for neuronio in self.ListaDeNeuronios:
      neuronio.adicionaEntradas(valoresDeEntrada)
      resultado.append(neuronio.calcularSaida())

    return resultado

  def backPropagation(self, listaDeErros : list[float], alfa : float) -> list[float]:
    if (len(self.ListaDeNeuronios) != len(listaDeErros)):
      raise Exception('A quantidade de valores de neuronios é diferente da quantidade de erros. ')

    listaDeFatoresDeErro : list[float] = []
    for i in range(len(self.ListaDeNeuronios)):
      erro = self.ListaDeNeuronios[i].backPropagation(listaDeErros[i], alfa)
      listaDeFatoresDeErro.append(erro)

    listaDeErros : list[float] = []
    for i in range(len(self.ListaDeNeuronios)):
      erroComposto = 0
      for z in range(len(self.ListaDeNeuronios)):
        erroComposto += self.ListaDeNeuronios[z].ListaDePesos[i] * listaDeFatoresDeErro[z]
      listaDeErros.append(erroComposto)

    return listaDeErros

  def atualizaPesos(self):
    for neuronio in self.ListaDeNeuronios:
      neuronio.atualizaPesos()

  def mostrarPesos(self):
    for neuronio in self.ListaDeNeuronios:
      neuronio.mostrarPesos()

"""Classe da Rede"""

class RedeNeural:
  ListaDeCamadas : list[Camada]
  Alfa : float
  DistanciaAceitavel : float

  def __init__(self, alfa, distancia_aceitavel, numero_de_camadas, numero_de_neuronios):
    self.ListaDeCamadas = []

    for i in range(numero_de_camadas):
      camada = Camada(i, numero_de_neuronios)
      self.ListaDeCamadas.append(camada)

    self.Alfa = alfa
    self.DistanciaAceitavel = distancia_aceitavel


  def formatarEntrada(self, linha : list[list[float]]) -> list[float]:
    resulta : list[float] = []
    numeroTotalLinhas = len(linha) - 1
    medianaDeLinhas = ((numeroTotalLinhas - 1) // 2) + 1
    for i in range(len(linha[0])):
      elemento = 0
      for j in range(numeroTotalLinhas):
        elemento = elemento + (linha[j][i] * abs(medianaDeLinhas - abs(medianaDeLinhas - (j + 1))))
      resulta.append(elemento)

    return resulta

  def formatarSaida(self, linha : list[list[float]]) -> list[float]:
    return linha[-1]

  def verificaValor(self, valoresDeResultado : list[float], valoresEsperados : list[float]):
    for i in range(len(valoresDeResultado)):
      diff = valoresDeResultado[i] - valoresEsperados[i]
      if(abs(diff) > self.DistanciaAceitavel):
        return False
    return True

  def calcular(self, valoresDeEntrada : list[float]) -> list[float]:
    if (len(self.ListaDeCamadas) == 0):
      return valoresDeEntrada

    resultado : list[float] = valoresDeEntrada
    for camada in self.ListaDeCamadas:
      resultado = camada.calcular(resultado)

    return resultado

  def backPropagation(self, valoresDeResultado : list[float], valoresEsperados : list[float]):
    if (len(valoresDeResultado) != len(valoresEsperados)):
      raise Exception('A quantidade de valores de saida é diferente da quantidade de valores esperados. ')

    # calcula o vetor inicial de erro
    listaDeErros : list[float] = []
    for i in range(len(valoresDeResultado)):
      listaDeErros.append(valoresEsperados[i] - valoresDeResultado[i])

    # pra cada camada, pega o novo vetor de erro
    listaDeFatoresDeErro : list[float] = listaDeErros
    for camada in reversed(self.ListaDeCamadas):
      listaDeFatoresDeErro = camada.backPropagation(listaDeFatoresDeErro, self.Alfa)

    # atualiza os pesos de todos neuronios das camadas
    for camada in self.ListaDeCamadas:
      camada.atualizaPesos()

  def mostrarPesos(self):
    for camada in self.ListaDeCamadas:
      camada.mostrarPesos()

"""Implementação da Rede Neural

Importando o conjunto de dados
"""

import csv

rawCleanedChars : list[list[list[float]]] = []

with open('/content/sample_data/caracteres-limpo.csv') as csv_file:
  csv_reader = csv.reader(csv_file, delimiter=',')

  z = 0
  for row in csv_reader:
    line : list[list[float]] = []
    for i in range(len(row)):
      if (i % 7 == 0):
        line.append([])

      if (row[i] == "-1"):
        line[i//7].insert(i%7, -1)
      elif (row[i] == "1"):
        line[i//7].insert(i%7, 1)
      else:
        line[i//7].insert(i%7, 0)

    rawCleanedChars.insert(z, line)
    z = z + 1

rawGarbageChars : list[list[list[float]]] = []

with open('/content/sample_data/caracteres-ruido.csv') as csv_file:
  csv_reader = csv.reader(csv_file, delimiter=',')

  z = 0
  for row in csv_reader:
    line : list[list[float]] = []
    for i in range(len(row)):
      if (i % 7 == 0):
        line.append([])

      if (row[i] == "-1"):
        line[i//7].insert(i%7, -1)
      elif (row[i] == "1"):
        line[i//7].insert(i%7, 1)
      else:
        line[i//7].insert(i%7, 0)

    rawGarbageChars.insert(z, line)
    z = z + 1

rawGarbage2Chars : list[list[list[float]]] = []

with open('/content/sample_data/caracteres_ruido20.csv') as csv_file:
  csv_reader = csv.reader(csv_file, delimiter=',')

  z = 0
  for row in csv_reader:
    line : list[list[float]] = []
    for i in range(len(row)):
      if (i % 7 == 0):
        line.append([])

      if (row[i] == "-1"):
        line[i//7].insert(i%7, -1)
      elif (row[i] == "1"):
        line[i//7].insert(i%7, 1)
      else:
        line[i//7].insert(i%7, 0)

    rawGarbage2Chars.insert(z, line)
    z = z + 1

"""PS: ultima linha do registro é a resposta"""

print(rawCleanedChars)
print(rawGarbageChars)
print(rawGarbage2Chars)

rede : RedeNeural = RedeNeural(0.05, 0.20, 3, 7)

entrada = rawCleanedChars[0]
resultado = rawCleanedChars[0][-1]
exemplo_entrada = rede.formatarEntrada(entrada)

print(exemplo_entrada)
print(resultado)
print(entrada)

import random

allSample : list[list[list[float]]] = []

for row in rawCleanedChars:
  allSample.append(row)

for row in rawGarbageChars:
  allSample.append(row)

for row in rawGarbage2Chars:
  allSample.append(row)

random.shuffle(allSample)

print(len(allSample))

"""Por numero de epocas"""

numeroDeEpocas = 15000

numeroDeTeste = 53

testes : list[list[list[float]]] = []

validacoes : list[list[list[float]]] = []


for row in allSample:
  if (len(testes) < numeroDeTeste):
    testes.append(row)
  else:
    validacoes.append(row)

print("Número de casos de treinamento: " + str(len(testes)))
print("Número de casos de teste: " + str(len(validacoes)))

import pdb;

# 7 linhas de classes e 1 de totais
# 7 colunas de classes, 1 de erros de previsão e 1 de totais (não preveram nenhuma classe, mesmo errada, o suficiente)
# inicialmente tudo com zeros
# linhas são classes esperadas e colunas são classes preditas
# ex: matrizDeConfusao = [saida esperada][saida obtida]
matrizDeConfusao = [[0] * 9 for _ in range(8)]

rede : RedeNeural = RedeNeural(0.015, 0.60, 3, 7)

rede.mostrarPesos()


for i in range(numeroDeEpocas):
  for row in testes:
    saida = rede.formatarSaida(row)
    entrada = rede.formatarEntrada(row)
    resultado = rede.calcular(entrada)
    if (not (rede.verificaValor(resultado, saida))):
      rede.backPropagation(resultado, saida)
print(" ")
rede.mostrarPesos()

print(" ")

print("Conjunto de treinamento: ")
acertos = 0
for row in testes:
  saidaEsperada = rede.formatarSaida(row)
  entrada = rede.formatarEntrada(row)
  saidaObtida = rede.calcular(entrada)

  if (rede.verificaValor(saidaObtida, saidaEsperada)):
    acertos += 1




print(" ")
print("Testes acertados foram " + str(acertos) + " de " + str(numeroDeTeste))

print(" ")

print("Conjunto de teste: ")
print()

print("Erros: ")

acertos = 0
for row in validacoes:
  saida = rede.formatarSaida(row)
  entrada = rede.formatarEntrada(row)
  resultado = rede.calcular(entrada)
  indexLetraSaidaEsperada = saida.index(max(saida))
  indexLetraSaidaObtida = resultado.index(max(resultado))

  if (rede.verificaValor(resultado, saida)):
    acertos += 1
    matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
  else:
    errouMasAcusou = True
    for i in saidaObtida:
      # só adiciona na matriz de confusão se, mesmo tendo errado, acusou um outro caractere
      if not (i < (1 - rede.DistanciaAceitavel) and i > (rede.DistanciaAceitavel - 1)):
        errouMasAcusou = False;

    if errouMasAcusou:
      # errou mas acusou alguma classe
      matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
    else:
      # errou e não acusou nada
      matrizDeConfusao[indexLetraSaidaEsperada][-2] += 1

    print(resultado)
    print(saida)

# calculando totais
for i in range (0, 7):
  for j in range(0, 8):
    matrizDeConfusao[i][8] += matrizDeConfusao[i][j]
for i in range (0, 8):
  for j in range(0, 7):
    matrizDeConfusao[7][i] += matrizDeConfusao[j][i]
for i in range (0, 7):
  matrizDeConfusao[7][8] += matrizDeConfusao[i][8]

print()

print("Matriz de Confusão (" + str(len(validacoes)) + " casos de validação):")
for row in matrizDeConfusao:
  print(row)

print(" ")


print("Testes acertados foram " + str(acertos) + " de " + str(len(validacoes)))

"""Por acuracia"""

from random import shuffle


rede : RedeNeural = RedeNeural(0.015, 0.50, 3, 7)

acuracia = 0
chunkSize = 9
chunkedList = []

testes : list[list[list[float]]] = []

validacoes : list[list[list[float]]] = []

while acuracia < 0.6:

  shuffle(allSample)
  chunkedList.clear()

  for i in range(0, len(allSample), chunkSize):
    chunkedList.append(allSample[i:i+chunkSize])

  for i in range(len(chunkedList)):
    matrizDeConfusao = [[0] * 9 for _ in range(8)]
    validacoes = chunkedList[i]
    testes.clear()
    for z in range(len(chunkedList)):
      if (z != i):
        for y in range(len(chunkedList[z])):
          testes.append(chunkedList[z][y])
    for row in testes:
      saida = rede.formatarSaida(row)
      entrada = rede.formatarEntrada(row)
      resultado = rede.calcular(entrada)

      if (not (rede.verificaValor(resultado, saida))):
        rede.backPropagation(resultado, saida)
    acertos = 0
    for row in validacoes:
      saida = rede.formatarSaida(row)
      entrada = rede.formatarEntrada(row)
      resultado = rede.calcular(entrada)
      indexLetraSaidaEsperada = saida.index(max(saida))
      indexLetraSaidaObtida = resultado.index(max(resultado))
      if (rede.verificaValor(resultado, saida)):
        acertos += 1
        matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
      else:
        errouMasAcusou = True
        for i in resultado:
          if not (i < (1 - rede.DistanciaAceitavel) and i > (rede.DistanciaAceitavel - 1)):
            errouMasAcusou = False;
        if errouMasAcusou:
          matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
        else:
          matrizDeConfusao[indexLetraSaidaEsperada][-2] += 1
    acuracia = acertos / len(validacoes)
    if (acuracia != 0):
      print("Acuracia: " + str(acuracia))

# calculando totais
for i in range (0, 7):
  for j in range(0, 8):
    matrizDeConfusao[i][8] += matrizDeConfusao[i][j]
for i in range (0, 8):
  for j in range(0, 7):
    matrizDeConfusao[7][i] += matrizDeConfusao[j][i]
for i in range (0, 7):
  matrizDeConfusao[7][8] += matrizDeConfusao[i][8]

rede.mostrarPesos()
print("Matriz de Confusão (" + str(len(validacoes)) + " casos de validação):")
for row in matrizDeConfusao:
  print(row)

print(" ")

print("Testes acertados foram " + str(acertos) + " de " + str(len(validacoes)))

"""K folds"""

numeroDeEpocas = 12000

k = 10
j = 1
folds : list[list[list[list[float]]]] = [[],[],[],[],[],[],[],[],[],[]]
random.shuffle(allSample)
# Subdivide os casos de teste aleatoriamente
for row in allSample:
  folds[j%k].append(row)
  j+=1

for i in range(len(folds)):
  rede : RedeNeural = RedeNeural(0.015, 0.60, 3, 7)
#Monta conjuntos de teste e validacao com base nos folds
  fteste : list[list[list[float]]] = []
  fvalidacao : list[list[list[float]]] = []
  matrizDeConfusao = [[0] * 9 for _ in range(8)]
  for n in range(len(folds)):
    for row in folds[n]:
      if(n==i): fvalidacao.append(row)
      else: fteste.append(row)
#treinamento
  for e in range(numeroDeEpocas):
    for row in fteste:
      saida = rede.formatarSaida(row)
      entrada = rede.formatarEntrada(row)
      resultado = rede.calcular(entrada)

      if (not (rede.verificaValor(resultado, saida))):
        rede.backPropagation(resultado, saida)
#validacao e matriz de confusao
    acertos = 0
  for row in fvalidacao :
    saida = rede.formatarSaida(row)
    entrada = rede.formatarEntrada(row)
    resultado = rede.calcular(entrada)
    indexLetraSaidaEsperada = saida.index(max(saida))
    indexLetraSaidaObtida = resultado.index(max(resultado))
    if (rede.verificaValor(resultado, saida)):
      acertos += 1
      matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
    else:
      errouMasAcusou = True
      for i in resultado:
        if not (i < (1 - rede.DistanciaAceitavel) and i > (rede.DistanciaAceitavel - 1)):
          errouMasAcusou = False;
      if errouMasAcusou:
        matrizDeConfusao[indexLetraSaidaEsperada][indexLetraSaidaObtida] += 1
      else:
        matrizDeConfusao[indexLetraSaidaEsperada][-2] += 1
  print(" ")
  print("Testes acertados foram " + str(acertos) + " de " + str(len(fvalidacao)))
  # calculando totais
  for i in range (0, 7):
    for j in range(0, 8):
      matrizDeConfusao[i][8] += matrizDeConfusao[i][j]
  for i in range (0, 8):
    for j in range(0, 7):
      matrizDeConfusao[7][i] += matrizDeConfusao[j][i]
  for i in range (0, 7):
    matrizDeConfusao[7][8] += matrizDeConfusao[i][8]

  print("Matriz de Confusão (" + str(len(fvalidacao)) + " casos de validação):")
  for row in matrizDeConfusao:
    print(row)



print(" ")